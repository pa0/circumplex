<!-- 03 
Współczynnik omega dla każdej skali i alfa Cronbacha dla każdej podskali, aby ocenić, czy pozycje są spójne.
-->

```{r}
#| eval: false
# niepotrzebne - jest w TableOne
researchs_n = dane %>%
  group_by(set) %>%
  count() %>%
  pull(n, name = set)
n = sum(researchs_n)

c(researchs_n, total = n)

```

```{r}
#| message: false
#| warning: false

# Nazwy skal i podskal oraz kierunek w kluczu
get_subscales = function(scale){
  codebook %>%
    filter(str_sub(eng2, 1, str_length(scale)) == scale) %>%
    pull(key) %>%
    str_remove('-') %>% unique() %>% sort()
  }

scales = c('CSIV', 'IIPC', 'ISC', 'PICD', 'HSNS', 'IJZ', 'SIFS', 'RAS', 'SCL')
subscales_list = sapply(scales, get_subscales)
scales_factors = sapply(subscales_list, length)

#list2env(subscales_list, envir = .GlobalEnv)

```


```{r}
# Funkcje do liczenia wskaźników rzetelności
compute_omega = function(scale) {
  if (scales_factors[scale] == 1) {
    psych::alpha(
      dane %>%
        select(matches(str_c(
          scale, '.*\\d+$'
        )), -SCL_20) %>%
        mutate(across(everything(), as.integer)) %>%
        janitor::remove_empty(which = 'rows')
    )$total$std.alpha |> round(2)
    
  } else {
    psych::omega(
      dane %>%
        select(matches(str_c(
          scale, '.*\\d+$'
        )), -SCL_20) %>%
        mutate(across(everything(), as.integer)) %>%
        janitor::remove_empty(which = 'rows'),
      
      key = codebook |> filter(str_sub(eng2, 1, str_length(scale)) == scale) |>
        filter(!str_detect(eng2, "\\d+(a|b)$")) |>
        pull(key) %>% grepl("-", .) %>%
        ifelse(., -1, 1),
      
      fm = "minres",
      nfactors = scales_factors[scale],
      plot = FALSE
    )$omega.tot |> round(2)
  }
}


compute_alpha_sub = function(scale, subscale) {
  if ((codebook %>% filter(str_sub(eng2, 1, str_length(scale)) == scale &
                           key == !!subscale) %>% nrow()) > 1) {
    psych::alpha(
      dane %>%
        select(
          codebook %>%
            filter(str_sub(eng2, 1, str_length(scale)) == scale &
                     key == !!subscale) %>%
            pull(eng2),-matches('\\d+(a|b)$')
        ) %>%
        mutate(across(everything(), as.integer)) %>%
        janitor::remove_empty(which = 'rows'),
      # uwzględnia kierunek kodowania
      keys = names(dane)[which(grepl("-", codebook |> filter((key |> str_remove('-')) == subscale) |> select(key) |> pull(key)))]
    )$total$std.alpha |> round(2)
  } else {NA}
}
```


```{r, message=F, warning=F}

# Wartość Omega

omega_scales = sapply(scales, compute_omega)
cat("Wartości omega\n")
omega_scales

# IJZ       - An ultra-Heywood case was detected. Examine the results carefull; diag(.) had 0 or NA entries; non-finite result is doubtful

# IJZ, CSIV - The estimated weights for the factor scores are probably incorrect. Try a different factor score estimation method
# HSNS, RAS - Omega_h for 1 factor is not meaningful, just omega_t; Omega_h and Omega_asymptotic are not meaningful with one factor

```


```{r}

# Wartość Alpha Cronbacha

# tylko podskale

alpha_subscales <-  lapply(sapply(scales, function(scale) 
    sapply(subscales_list[[scale]], function(subscale)
    compute_alpha_sub(scale, subscale))), function(subalphas)
      setNames(subalphas, str_to_lower(names(subalphas))))

cat("Wartości alfa\n")
alpha_subscales 


```




```{r}
#| eval: false

# Nie wiem po co to na razie
# skorelowane zmienne IJZ

dane %>%
    select(matches('IJZ.*\\d+$')) %>%
    mutate(across(everything(), as.integer)) %>%
    corrr::correlate(method = 'spearman') %>% 
    corrr::stretch(na.rm = TRUE, remove.dups = TRUE) %>% 
    arrange(-r)

psych::omega(dane %>%
               select(matches('IJZ.*\\d+$'), -IJZ_9, -IJZ_10, -IJZ_3, -IJZ_11, -IJZ_12, -IJZ_20, -IJZ_7) %>%
               mutate(across(everything(), as.integer)) %>%
               janitor::remove_empty(which = 'rows'),  
    nfactors = scales_factors['IJZ'], plot = FALSE)$omega.tot

```



